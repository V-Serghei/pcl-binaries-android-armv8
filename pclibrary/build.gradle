import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    alias(libs.plugins.android.library)
    alias(libs.plugins.jetbrains.kotlin.android)
    id("maven-publish")

}

tasks.register('mergeArchiveParts') {
    def archiveDir = file('src/main/cpp/pclib/jniLibs/arm64-v8a/pcl/lib')

    doLast {
        def zipFiles = [
                'libpcl_tracking.zip',
                'libpcl_surface.zip',
                'libpcl_common.zip',
                'libpcl_features.zip',
                'libpcl_filters.zip',
                'libpcl_io.zip',
                'libpcl_io_ply.zip',
                'libpcl_kdtree.zip',
                'libpcl_keypoints.zip',
                'libpcl_ml.zip',
                'libpcl_octree.zip',
                'libpcl_recognition.zip',
                'libpcl_registration.zip',
                'libpcl_sample_consensus.zip',
                'libpcl_search.zip',
                'libpcl_segmentation.zip',
                'libpcl_stereo.zip'
        ]

        zipFiles.each { archiveName ->
            def outputFile = file("${archiveDir}/${archiveName}")

            def partsPattern = "${archiveName}.*"
            def parts = fileTree(dir: archiveDir, includes: [partsPattern])
            boolean allPartsExist = parts.files.size() > 0

            if (allPartsExist) {
                println "Merging parts for ${archiveName}..."

                if (!outputFile.exists()) {
                    def outputStream = new FileOutputStream(outputFile, true)

                    parts.each { part ->
                        outputStream.write(part.bytes)
                        println "Added: ${part.name}"
                    }

                    outputStream.close()
                    println "Merge completed, file: $outputFile"
                } else {
                    println "File ${archiveName} already exists, skipping merge."
                }
            } else {
                println "Not all parts for ${archiveName} are available, skipping merge."
            }
        }
    }
}


tasks.register('extractArchives') {
    def archiveDir = file('src/main/cpp/pclib/jniLibs/arm64-v8a/pcl/lib')

    doLast {
        def archives = [
                'libpcl_tracking.zip',
                'libpcl_surface.zip',
                'libpcl_common.zip',
                'libpcl_features.zip',
                'libpcl_filters.zip',
                'libpcl_io.zip',
                'libpcl_io_ply.zip',
                'libpcl_kdtree.zip',
                'libpcl_keypoints.zip',
                'libpcl_ml.zip',
                'libpcl_octree.zip',
                'libpcl_recognition.zip',
                'libpcl_registration.zip',
                'libpcl_sample_consensus.zip',
                'libpcl_search.zip',
                'libpcl_segmentation.zip',
                'libpcl_stereo.zip'
        ]

        archives.each { archiveName ->
            def archiveFile = file("${archiveDir}/${archiveName}")

            if (archiveFile.exists()) {
                if (Os.isFamily(Os.FAMILY_WINDOWS)) {
                    exec {
                        commandLine 'powershell', '-command', "& {Expand-Archive -Path '${archiveFile}' -DestinationPath '${archiveDir}' -Force}"
                    }
                } else {
                    exec {
                        commandLine 'bash', '-c', "unzip ${archiveFile} -d ${archiveDir}"
                    }
                }

                println "Archive ${archiveName} successfully unpacked!"

                if (archiveFile.exists()) {
                    archiveFile.delete()
                    println "Deleted archive ${archiveName}"
                }

                def parts = fileTree(dir: archiveDir, includes: ["${archiveName}.*"])
                parts.each { part ->
                    if (part.exists()) {
                        part.delete()
                        println "Deleted part of archive ${part.name}"
                    }
                }
            } else {
                println "Archive ${archiveName} does not exist, skipping extraction."
            }
        }
    }
}

extractArchives.dependsOn mergeArchiveParts

preBuild.dependsOn extractArchives




subprojects {
    apply plugin: "maven-publish"
    publishing {
        repositories {
            maven {
                name = "pcl-binaries-android-armv8"
                url = uri("https://github.com/V-Serghei/pcl-binaries-android-armv8")
                credentials {
                    username = project.findProperty("gpr.user") ?: System.getenv("V-Serghei")
                    password = project.findProperty("gpr.key") ?: System.getenv("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")
                }
            }
        }
        publications {
            gpr(MavenPublication) {
                from(components.java)
            }
        }
    }
}

android {
    namespace 'com.example.pclibrary'
    compileSdk 34

    defaultConfig {
        minSdk 29

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"
        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
        ndk {
            abiFilters "arm64-v8a"
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.22.1"
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    kotlinOptions {
        jvmTarget = '1.8'
    }




}

dependencies {
    implementation libs.androidx.core.ktx
    implementation libs.androidx.appcompat
    implementation libs.material
    testImplementation libs.junit
    androidTestImplementation libs.androidx.junit
    androidTestImplementation libs.androidx.espresso.core
}
